<h1 id="category-theory">Category Theory</h1>
<p>Vocabulary: <em>object</em>, <em>arrow</em>, <em>composition</em>, <em>identity arrow</em>, <em>associative law</em>.</p>
<h2 id="objects-and-arrows">Objects and Arrows</h2>
<p>f: A -&gt; B is an <em>arrow</em>, f, from object A to object B.</p>
<p>A is the <em>domain</em> of f and B is the <em>codomain</em> of f, aka <em>range</em>, <em>target</em>, or <em>but</em> if you parlez Francais, but codomain is more apropos when we get to 'opposite day' furthur on.</p>
<p>We could do away with objects using domain and codomain, just as it is possible to use nand to define the logical operators not, and, or, implies, but why make things more difficult?</p>
<h2 id="composition">Composition</h2>
<p>If f: A -&gt; B and g: B -&gt; C then there exists an arrow g o f: A -&gt; C, the <em>composition</em> of f with g.</p>
<p>Or maybe the composition of g with f. Some people get caught up with trivialities. How come f and g get written in the reverse order?</p>
<p>You could define f;g (or your favorite binary operator symbol instead of ;) to be g o f. Or just write the arrows backwards. Let's agree to drop the ' o ' and write gf instead.</p>
<h2 id="identity-arrow">Identity Arrow</h2>
<p>On to more interesting things. Every object has an <em>identity arrow</em>. If f: A -&gt; B then the identity arrows 1_A and 1_B satisfy f 1_A = f = 1_B f. Or maybe only somewhat more interesing. You can always throw in identity arrows if they don't exist.</p>
<h3 id="exercises">Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>If e: A -&gt; A has the property fe = f for all f: A -&gt; B then e = 1_A.</p></li>
<li><p>If e: B -&gt; B has the property ef = f for all f: A -&gt; B then e = 1_B.</p></li>
</ol>
<h2 id="associative-law">Associative Law</h2>
<p>If f: A -&gt; B, g: B -&gt; C, and h: C -&gt; D then hgf is unambiguous in category theory. The associative law is (hg)f = h(gf).</p>
<h2 id="examples">Examples</h2>
<p>It is impossible to understand Category Theory without understanding examples of categories. That is its raison d'etre. Many seemingly disparate constructs can be unified a la mode de chez Category Theory.</p>
<p>The primary example of a category is <em>Set</em>. The objects are sets and the arrows are functions. People tried to come up with a purely category theory notion of Set and ended up with <em>topos</em> theory. One does not simply consider 'elements' of a 'set'. Long story.</p>
<p>Then there is <em>Par</em>, the category of partial functions. It gets no respect. Most functions are actually partial functions. The function x -&gt; 1/x is not a function from the real numbers to the real numbers.</p>
<p><em>Rel</em> is the category of relations. It generalizes <em>Set</em> and <em>Par</em>. Given sets A and B, a <em>relation</em> is a subset of the cartesian product A x B.</p>
<p>A function, f, is a relation with the property that for every a in A there exists a unique b in B such that (a,b) in f.</p>
<p>A partial function, g, is a relation with the property that for every a in A there exists at most one b in B such that (a,b) in f.</p>
<p>Composition of the relation R, contained in A x B, and the relation S contained in B x C is SR = {(a,c) in A x C : there is a b in B with (a,b) in R and (b,c) in S}</p>
<p>Exercise: Show the identity 1_A = {(a,a) : a in A} and that composition is associative.</p>
<p>There are a slew of examples of categories where the objects are sets 'with structure' and the arrows are functions that preserve that structure.</p>
<p><em>Grp</em> is the category of groups: the objects are groups and the arrows are <em>homomorphisms</em> (functions) that preserve the group structure.</p>
